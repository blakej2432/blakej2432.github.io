---
layout: post
title: Django 장고 프로젝트의 기본 구조
date: 2024-08-07 22:55 +0900
categories:
  - Backend
  - Django
tags: 
math: true
---
## 애플리케이션 개발 패턴

**MVC** (Model-View-Controller) 패턴

- Model: 애플리케이션의 데이터 로직을 처리하는 파트
- View: 사용자 인터페이스, 사용자의 입력과 데이터 표시를 담당하는 파트
- Controller: Model과 View의 사이에서 사용자 요청 처리, 데이터 흐름 관리하는 파트

**MVT** (Model-View-Template) 패턴

- Model: 애플리케이션의 데이터 로직을 처리하는 파트
- View: MVC의 Controller에 해당, 사용자 요청 처리, 데이터 흐름 관리
- Template: MVC의 View에 해당, 인터페이스 구성, 데이터 표시


장고는 기본적으로 MVT 패턴으로 개발하는 프레임워크
파일구성

> settings.py

> models.py → M

> urls.py

> views.py → V

> templates → T

-----

### Model Class 작성법

```python
class Post(models.Model):

	title = models.CharField(verbose_name="TITLE", max_length=50)
	author = ...
	...
	
		def __str__(self): # 객체를 반환할 때 title을 표시
			return self.title
			
		def get_absolute_url(self): # 객체의 절대 URL을 반환. URL 설정 변경에 유연하게 대응
			return reverse('blog:post_detail', args=(self.id,))
			
		def get_prev(self): # 현 객체보다 modify_dt가 이전인 객체 반환
			return self.get_previous_by_modify_dt()
		
		def get_next(self): # 현 객체보다 modify_dt가 이후인 객체 반환
			return self.get_next_by_modify_dt()
```

- DB는 개발 초기 스키마 결정 단계는 SQLite로 작업하고 나중에 Postgre, MySQL로 변경

-------

### Admin 시작

```python
@admin.register(Post) # 데코레이터로 등록하기
class PostAdmin(admin.ModelAdmin):
	list_display = ('id', 'title', 'modify_dt')
```


### urls.py

```python
urlpatterns = [
	path('post/list/', views.PostLV.as_view(), name='post_list')
]
```


### views.py

```python
class PostLV(ListView):
	model = Post
	template_name = 'blog/post_list.html' # default 생략 가능
	
```


### template

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>post_list.html</html>
</head>
<body>
this is post_list.html
</body>
</html>
```


-----

### 사용자 인증

```python

class Post(models.Model):
	title = models.CharField(verbose_name="TITLE", max_length=50)
	
	owner = models.ForeignKey(User, on_delete=models.CASCADE) # User 부분 아래에서 변경 예정
	

```
- User table은 장고 내에서 유저 인증을 위한 기본 테이블
- 프로젝트 초기에 이를 어떻게 설정할 것인지 잡고 가자
- 기본 User를 사용하면 커스텀(컬럼 변경)에 제약이 생길 수 있다
- 장고 Document에서 추천하는 방식은 차후에라도 변경이 가능하도록 AbstractUser를 사용

1. 인증 관리를 위한 accounts 앱 폴더 만들기
2. accounts - settings.py에 'accounts.apps.AccountsConfig' 추가

3. Models.py에 User 테이블 정의

```python 
class User(AbstractUser):
	pass
```


4. admin.py에 register

```python
from accounts.models import User # 장고가 기본 제공하는 User 아님!, AbstractUser를 상속받아 만든 User임

admin.site.register(User, UserAdmin)
```


5. 프로젝트의 settings.py에 AUTH_USER_MODEL = 'accounts.User' 추가

6. 유저 테이블 호출 바꿔주기
```python
from django.contrib.auth import get_user_model


class Post(models.Model):
	title = models.CharField(verbose_name="TITLE", max_length=50)
	
	owner = models.ForeignKey(get_user_model(), on_delete=models.CASCADE) # 만들어 놓은 Custom User로 불러오기 
```


----

### settings.py 관리

- 애플리케이션의 설정(settings.py)는 개발용과 배포용이 다를 수 있다 (대부분 다르다)
- settings.py를 개발용, 배포용, 공통 부분 으로 나누어주자

1. settings 폴더 생성
2. base.py, develop.py, product.py 생성
3. base.py에 공통부분만 남겨 놓고, import 해주기
```python
from .base import *
```

4. SECRET_KEY, DEBUG, ALLOWED_HOSTS, DATABASES 다르게 설정(develop.py, product.py)

5. 각 설정의 호출
	- 개발 시 : manage.py에서 'project.settings.develop'
	- 배포 시 : wsgi.py에서 'project.settings.product'
